use {
    axum::{
        extract::{Path, Query, ws::{WebSocket, WebSocketUpgrade}},
        http::StatusCode,
        response::{Html, Response},
        routing::{get, post, delete},
        Json, Router,
    },
    bs58,
    chrono::{DateTime, Utc},
    futures::{stream::StreamExt, sink::SinkExt},
    log::{debug, error, info, warn},
    redb::{Database, TableDefinition, ReadableTable},
    serde::{Deserialize, Serialize},
    solana_client::rpc_client::RpcClient,
    solana_program::{program_pack::Pack, pubkey::Pubkey as ProgramPubkey},
    solana_sdk::pubkey::Pubkey,
    spl_associated_token_account::get_associated_token_address,
    spl_token::state::Account as TokenAccount,
    std::{
        collections::{HashMap, VecDeque},
        fs,
        str::FromStr,
        sync::{Arc, Mutex},
        time::Duration,
    },

    tower_http::cors::CorsLayer,
    yellowstone_grpc_client::GeyserGrpcClient,
    yellowstone_grpc_proto::{
        geyser::SubscribeUpdate,
        prelude::{
            CommitmentLevel, SubscribeRequest, SubscribeRequestFilterAccounts,
            subscribe_update::UpdateOneof,
        },
    },
};

// Â∏∏Êï∏ÂÆöÁæ©
const WSOL_MINT: &str = "So11111111111111111111111111111111111111112";
const TOKEN_PROGRAM_ID: &str = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
const ASSOCIATED_TOKEN_PROGRAM_ID: &str = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
const MAX_HISTORY_SIZE: usize = 10000000;
const DB_FILE: &str = "wallet_history.redb";

// Ë≥áÊñôÂ∫´Ë°®Ê†ºÂÆöÁæ©
const WALLET_HISTORY_TABLE: TableDefinition<&str, &str> = TableDefinition::new("wallet_history");

// API Áõ∏ÈóúÁµêÊßã
#[derive(Debug, Serialize, Deserialize)]
struct WalletSummary {
    address: String,
    name: String,
    sol_balance: f64,
    wsol_balance: f64,
    total_balance: f64,
    last_update: DateTime<Utc>,
    sampled_history: Vec<BalanceHistory>, // Êé°Ê®£ÂæåÁöÑÊ≠∑Âè≤Êï∏Êìö
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct BalanceHistory {
    timestamp: DateTime<Utc>,
    sol_balance: f64,
    wsol_balance: f64,
    total_balance: f64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct ChartDataPoint {
    time: i64, // Unix timestamp in seconds
    value: f64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct WalletHistoryRecord {
    timestamp: DateTime<Utc>,
    address: String,
    sol_balance: f64,
    wsol_balance: f64,
    total_balance: f64,
}

impl WalletHistoryRecord {
    fn new(address: String, sol_balance: f64, wsol_balance: f64) -> Self {
        Self {
            timestamp: Utc::now(),
            address,
            sol_balance,
            wsol_balance,
            total_balance: sol_balance + wsol_balance,
        }
    }
}

#[derive(Debug, Deserialize)]
struct ChartQueryParams {
    wallet: String,
    data_type: String, // "sol", "wsol", or "total"
    interval: String,  // "5M", "10M", "30M", "1H", "2H", "4H", "8H", "12H", "1D", "1W", "ALL"
}

#[derive(Debug, Deserialize)]
struct AddWalletRequest {
    name: String,
    address: String,
}

#[derive(Debug, Serialize)]
struct ApiResponse {
    success: bool,
    message: String,
}

#[derive(Debug, Serialize)]
struct ErrorResponse {
    error: String,
}

// ÈÖçÁΩÆÁµêÊßã
#[derive(Debug, Deserialize, Clone)]
struct Config {
    grpc: GrpcConfig,
    rpc: RpcConfig,
    wallets: Vec<WalletConfig>,
    logging: LoggingConfig,
    server: ServerConfig,
}

#[derive(Debug, Deserialize, Clone)]
struct GrpcConfig {
    endpoint: String,
}

#[derive(Debug, Deserialize, Clone)]
struct RpcConfig {
    endpoint: String,
}

#[derive(Debug, Deserialize, Clone)]
struct WalletConfig {
    address: String,
    name: String,
}

#[derive(Debug, Deserialize, Clone)]
struct LoggingConfig {
    level: String,
}

#[derive(Debug, Deserialize, Clone)]
struct ServerConfig {
    host: String,
    port: u16,
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            host: "127.0.0.1".to_string(),
            port: 3000,
        }
    }
}

// Èå¢ÂåÖÈ§òÈ°çËøΩËπ§Âô®
#[derive(Debug, Clone)]
struct WalletBalance {
    address: String,
    name: String,
    sol_balance: f64,
    wsol_balance: f64,
    wsol_initialized: bool,
    last_update: DateTime<Utc>,
    history: VecDeque<BalanceHistory>,
}

impl WalletBalance {
    fn new(address: String, name: String) -> Self {
        Self {
            address,
            name,
            sol_balance: 0.0,
            wsol_balance: 0.0,
            wsol_initialized: false,
            last_update: Utc::now(),
            history: VecDeque::new(),
        }
    }

    fn update_sol(&mut self, lamports: u64) {
        self.sol_balance = lamports as f64 / 1_000_000_000.0;
        self.last_update = Utc::now();
        // Âè™ÊúâÂú®WSOLÂ∑≤ÂàùÂßãÂåñÂæåÊâçË®òÈåÑÊ≠∑Âè≤
        if self.wsol_initialized {
            self.add_to_history();
        }
    }

    fn update_wsol(&mut self, amount: f64) {
        self.wsol_balance = amount;
        self.wsol_initialized = true;
        self.last_update = Utc::now();
        // Âè™ÊúâÂú®WSOLÂ∑≤ÂàùÂßãÂåñÂæåÊâçË®òÈåÑÊ≠∑Âè≤
        if self.wsol_initialized {
            self.add_to_history();
        }
    }

    fn initialize_wsol(&mut self, amount: f64) {
        self.wsol_balance = amount;
        self.wsol_initialized = true;
        self.last_update = Utc::now();
        // Âè™ÊúâÂú®Ê≤íÊúâÊ≠∑Âè≤Ë®òÈåÑÊôÇÊâçÊ∑ªÂä†Á¨¨‰∏ÄÊ¢ùË®òÈåÑ
        if self.history.is_empty() {
            self.add_to_history();
        }
    }

    fn total_balance(&self) -> f64 {
        if !self.wsol_initialized {
            self.sol_balance
        } else {
            self.sol_balance + self.wsol_balance
        }
    }

    fn add_to_history(&mut self) {
        let history_point = BalanceHistory {
            timestamp: self.last_update,
            sol_balance: self.sol_balance,
            wsol_balance: if self.wsol_initialized { self.wsol_balance } else { 0.0 },
            total_balance: self.total_balance(),
        };

        self.history.push_back(history_point);
        
        // ÈôêÂà∂Ê≠∑Âè≤Ë®òÈåÑÂ§ßÂ∞è
        while self.history.len() > MAX_HISTORY_SIZE {
            self.history.pop_front();
        }
    }

    fn load_history_from_db(&mut self, records: Vec<WalletHistoryRecord>) {
        self.history.clear();
        for record in records {
            let history_point = BalanceHistory {
                timestamp: record.timestamp,
                sol_balance: record.sol_balance,
                wsol_balance: record.wsol_balance,
                total_balance: record.total_balance,
            };
            self.history.push_back(history_point);
        }
        
        // Ê≥®ÊÑèÔºö‰∏çÂæûÊ≠∑Âè≤Ë®òÈåÑË®≠ÁΩÆÈ§òÈ°çÔºåÂõ†ÁÇ∫WSOLÈ§òÈ°çÂèØËÉΩÈÅéÊôÇ
        // È§òÈ°çÂ∞áÂæûRPCÈáçÊñ∞Áç≤Âèñ‰ª•Á¢∫‰øùÊ∫ñÁ¢∫ÊÄß
        
        // ÈôêÂà∂Ê≠∑Âè≤Ë®òÈåÑÂ§ßÂ∞è
        while self.history.len() > MAX_HISTORY_SIZE {
            self.history.pop_front();
        }
    }

    fn to_summary(&self) -> WalletSummary {
        // Â∞çÊ≠∑Âè≤Êï∏ÊìöÈÄ≤Ë°åÊé°Ê®£Âà∞100Á≠Ü
        let sampled_history = if self.history.len() > 100 {
            let step = self.history.len() / 100;
            self.history.iter()
                .enumerate()
                .filter(|(i, _)| i % step == 0)
                .map(|(_, h)| h.clone())
                .take(100)
                .collect()
        } else {
            self.history.iter().cloned().collect()
        };
        
        WalletSummary {
            address: self.address.clone(),
            name: self.name.clone(),
            sol_balance: self.sol_balance,
            wsol_balance: if self.wsol_initialized { self.wsol_balance } else { 0.0 },
            total_balance: self.total_balance(),
            last_update: self.last_update,
            sampled_history,
        }
    }

    fn print_balance(&self, reason: &str) {
        if !self.wsol_initialized {
            info!(
                "üí∞ {} | {} ({}) | SOL: {:.6} | WSOL: Êú™ÂàùÂßãÂåñ | Á∏ΩË®à: {:.6}",
                reason,
                self.name,
                &self.address[..8],
                self.sol_balance,
                self.total_balance()
            );
        } else {
            info!(
                "üí∞ {} | {} ({}) | SOL: {:.6} | WSOL: {:.6} | Á∏ΩË®à: {:.6}",
                reason,
                self.name,
                &self.address[..8],
                self.sol_balance,
                self.wsol_balance,
                self.total_balance()
            );
        }
    }
}

type SharedWallets = Arc<Mutex<HashMap<String, WalletBalance>>>;
type SharedDatabase = Arc<Database>;

// gRPC ÊµÅÈáçÂïü‰ø°Ëôü
type GrpcRestartSignal = Arc<Mutex<bool>>;

// ÊáâÁî®ÁãÄÊÖãÁµêÊßã
#[derive(Clone)]
struct AppState {
    wallets: SharedWallets,
    database: SharedDatabase,
    grpc_restart_signal: GrpcRestartSignal,
    config: Config,
}

// Ë≥áÊñôÂ∫´Êìç‰ΩúÂáΩÊï∏
fn initialize_database() -> Result<Database, Box<dyn std::error::Error>> {
    let db = Database::create(DB_FILE)?;
    info!("üìä Ë≥áÊñôÂ∫´Â∑≤ÂàùÂßãÂåñ: {}", DB_FILE);
    Ok(db)
}

fn save_wallet_history(db: &Database, record: &WalletHistoryRecord) -> Result<(), Box<dyn std::error::Error>> {
    let write_txn = db.begin_write()?;
    {
        let mut table = write_txn.open_table(WALLET_HISTORY_TABLE)?;
        let key = format!("{}_{}", record.address, record.timestamp.timestamp_millis());
        let value = serde_json::to_string(record)?;
        table.insert(key.as_str(), value.as_str())?;
    }
    write_txn.commit()?;
    Ok(())
}

fn load_wallet_history(db: &Database, address: &str) -> Result<Vec<WalletHistoryRecord>, Box<dyn std::error::Error>> {
    let read_txn = db.begin_read()?;
    let table = read_txn.open_table(WALLET_HISTORY_TABLE)?;
    let mut records = Vec::new();
    
    let prefix = format!("{}_", address);
    let mut iter = table.iter()?;
    
    while let Some(entry) = iter.next() {
        let (key, value) = entry?;
        let key_str = key.value();
        if key_str.starts_with(&prefix) {
            let record: WalletHistoryRecord = serde_json::from_str(value.value())?;
            records.push(record);
        }
    }
    
    // ÊåâÊôÇÈñìÊéíÂ∫è
    records.sort_by_key(|r| r.timestamp);
    Ok(records)
}

fn delete_wallet_history(db: &Database, address: &str) -> Result<(), Box<dyn std::error::Error>> {
    let write_txn = db.begin_write()?;
    {
        let mut table = write_txn.open_table(WALLET_HISTORY_TABLE)?;
        let prefix = format!("{}_", address);
        
        // Êî∂ÈõÜÈúÄË¶ÅÂà™Èô§ÁöÑÈçµ
        let mut keys_to_delete = Vec::new();
        let mut iter = table.iter()?;
        while let Some(entry) = iter.next() {
            let (key, _) = entry?;
            let key_str = key.value();
            if key_str.starts_with(&prefix) {
                keys_to_delete.push(key_str.to_string());
            }
        }
        
        // Âà™Èô§ÊâæÂà∞ÁöÑÈçµ
        for key in keys_to_delete {
            table.remove(key.as_str())?;
        }
    }
    write_txn.commit()?;
    info!("üóëÔ∏è Â∑≤Âà™Èô§Èå¢ÂåÖ {} ÁöÑÊ≠∑Âè≤Êï∏Êìö", address);
    Ok(())
}

fn load_all_wallet_history(db: &Database) -> Result<HashMap<String, Vec<WalletHistoryRecord>>, Box<dyn std::error::Error>> {
    let read_txn = db.begin_read()?;
    let table = read_txn.open_table(WALLET_HISTORY_TABLE)?;
    let mut wallet_records: HashMap<String, Vec<WalletHistoryRecord>> = HashMap::new();
    
    let mut iter = table.iter()?;
    while let Some(entry) = iter.next() {
        let (_, value) = entry?;
        let record: WalletHistoryRecord = serde_json::from_str(value.value())?;
        wallet_records.entry(record.address.clone()).or_insert_with(Vec::new).push(record);
    }
    
    // Â∞çÊØèÂÄãÈå¢ÂåÖÁöÑË®òÈåÑÊåâÊôÇÈñìÊéíÂ∫è
    for records in wallet_records.values_mut() {
        records.sort_by_key(|r| r.timestamp);
    }
    
    Ok(wallet_records)
}

// Web API handlers
async fn get_wallets(axum::extract::State(state): axum::extract::State<AppState>) -> Json<Vec<WalletSummary>> {
    let wallets_guard = state.wallets.lock().unwrap();
    let summaries: Vec<WalletSummary> = wallets_guard.values().map(|w| w.to_summary()).collect();
    Json(summaries)
}

async fn get_wallet_detail(
    Path(address): Path<String>,
    axum::extract::State(state): axum::extract::State<AppState>,
) -> Result<Json<WalletSummary>, StatusCode> {
    let wallets_guard = state.wallets.lock().unwrap();
    match wallets_guard.get(&address) {
        Some(wallet) => Ok(Json(wallet.to_summary())),
        None => Err(StatusCode::NOT_FOUND),
    }
}

async fn get_chart_data(
    Query(params): Query<ChartQueryParams>,
    axum::extract::State(state): axum::extract::State<AppState>,
) -> Result<Json<Vec<ChartDataPoint>>, StatusCode> {
    let wallets_guard = state.wallets.lock().unwrap();
    let wallet = wallets_guard.get(&params.wallet).ok_or(StatusCode::NOT_FOUND)?;
    
    // Áç≤ÂèñÊâÄÊúâÊ≠∑Âè≤Êï∏Êìö
    let mut history: Vec<_> = wallet.history.iter().collect();
    
    // ÊéíÂ∫èÊ≠∑Âè≤Êï∏Êìö‰ª•Á¢∫‰øùÊôÇÈñìÈ†ÜÂ∫è
    history.sort_by_key(|h| h.timestamp);
    
    // Ê†πÊìöÊôÇÈñìÁØÑÂúçÈÅéÊøæÊï∏Êìö
    let now = Utc::now();
    let filtered_history: Vec<_> = match params.interval.as_str() {
        "5M" => history.into_iter().filter(|h| now.signed_duration_since(h.timestamp).num_minutes() <= 5).collect(),
        "10M" => history.into_iter().filter(|h| now.signed_duration_since(h.timestamp).num_minutes() <= 10).collect(),
        "30M" => history.into_iter().filter(|h| now.signed_duration_since(h.timestamp).num_minutes() <= 30).collect(),
        "1H" => history.into_iter().filter(|h| now.signed_duration_since(h.timestamp).num_hours() <= 1).collect(),
        "2H" => history.into_iter().filter(|h| now.signed_duration_since(h.timestamp).num_hours() <= 2).collect(),
        "4H" => history.into_iter().filter(|h| now.signed_duration_since(h.timestamp).num_hours() <= 4).collect(),
        "8H" => history.into_iter().filter(|h| now.signed_duration_since(h.timestamp).num_hours() <= 8).collect(),
        "12H" => history.into_iter().filter(|h| now.signed_duration_since(h.timestamp).num_hours() <= 12).collect(),
        "1D" => history.into_iter().filter(|h| now.signed_duration_since(h.timestamp).num_days() <= 1).collect(),
        "1W" => history.into_iter().filter(|h| now.signed_duration_since(h.timestamp).num_weeks() <= 1).collect(),
        "ALL" | _ => history,
    };
    
    let mut chart_data: Vec<ChartDataPoint> = filtered_history
        .iter()
        .filter_map(|h| {
            let value = match params.data_type.as_str() {
                "sol" => h.sol_balance,
                "wsol" => h.wsol_balance,
                "total" => h.total_balance,
                _ => h.total_balance,
            };
            
            // ÈÅéÊøæÊéâÁÑ°ÊïàÊï∏ÂÄº
            if value.is_finite() && !value.is_nan() {
                Some(ChartDataPoint {
                    time: h.timestamp.timestamp(),
                    value,
                })
            } else {
                None
            }
        })
        .collect();
    
    // ÂéªÈô§ÈáçË§áÊôÇÈñìÊà≥Ôºà‰øùÁïôÊúÄÊñ∞ÁöÑÔºâ
    chart_data.dedup_by_key(|point| point.time);
    
        // Âü∫ÊñºÊôÇÈñìÁöÑÂùáÂãªÊé°Ê®£Âà∞ 1000 Á≠ÜÊï∏Êìö
    let sampled_data = if chart_data.len() > 1000 {
        if chart_data.is_empty() {
            chart_data
        } else {
            let start_time = chart_data.first().unwrap().time;
            let end_time = chart_data.last().unwrap().time;
            let time_span = end_time - start_time;
            
            if time_span <= 0 {
                // Â¶ÇÊûúÊôÇÈñìË∑®Â∫¶ÁÇ∫0ÔºåÁõ¥Êé•ËøîÂõûÂéüÊï∏Êìö
                chart_data
            } else {
                let mut sampled = Vec::new();
                let sample_interval = time_span as f64 / 999.0; // 999ÂÄãÈñìÈöîÁî¢Áîü1000ÂÄãÈªû
                
                for i in 0..1000 {
                    let target_time = start_time + (i as f64 * sample_interval) as i64;
                    
                    // ÊâæÂà∞ÊúÄÊé•ËøëÁõÆÊ®ôÊôÇÈñìÁöÑÊï∏ÊìöÈªû
                    let closest_point = chart_data.iter()
                        .min_by_key(|point| (point.time - target_time).abs())
                        .unwrap();
                    
                    sampled.push(closest_point.clone());
                }
                
                // ÂéªÈô§ÈáçË§áÁöÑÊôÇÈñìÈªûÔºå‰øùÊåÅÊôÇÈñìÈ†ÜÂ∫è
                sampled.sort_by_key(|point| point.time);
                sampled.dedup_by_key(|point| point.time);
                
                info!("üìä ÂúñË°®Êï∏ÊìöÊôÇÈñìÊé°Ê®£: ÂéüÂßã {} Èªû -> Êé°Ê®£ {} Èªû (ÊôÇÈñìË∑®Â∫¶: {}Áßí)", 
                      chart_data.len(), sampled.len(), time_span);
                sampled
            }
        }
    } else {
        info!("üìä ÂúñË°®Êï∏ÊìöÁÑ°ÈúÄÊé°Ê®£: {} Èªû (‰∏äÈôê: 1000 Èªû)", chart_data.len());
        chart_data
    };

    info!("üìä ÂúñË°®Êï∏ÊìöÊ∫ñÂÇôÂÆåÊàê: {} Èªû (ÊôÇÈñìÁØÑÂúç: {})", sampled_data.len(), params.interval);
    
    Ok(Json(sampled_data))
}

async fn add_wallet(
    axum::extract::State(state): axum::extract::State<AppState>,
    Json(request): Json<AddWalletRequest>,
) -> Result<Json<ApiResponse>, (StatusCode, Json<ErrorResponse>)> {
    let name = request.name.trim();
    let address = request.address.trim();
    
    // È©óË≠âËº∏ÂÖ•
    if name.is_empty() {
        return Err((StatusCode::BAD_REQUEST, Json(ErrorResponse {
            error: "Èå¢ÂåÖÂêçÁ®±‰∏çËÉΩÁÇ∫Á©∫".to_string(),
        })));
    }
    
    if address.is_empty() {
        return Err((StatusCode::BAD_REQUEST, Json(ErrorResponse {
            error: "Èå¢ÂåÖÂú∞ÂùÄ‰∏çËÉΩÁÇ∫Á©∫".to_string(),
        })));
    }
    
    if address.len() < 32 || address.len() > 44 {
        return Err((StatusCode::BAD_REQUEST, Json(ErrorResponse {
            error: "Èå¢ÂåÖÂú∞ÂùÄÈï∑Â∫¶‰∏çÊ≠£Á¢∫".to_string(),
        })));
    }
    
    // Ê™¢Êü•Èå¢ÂåÖÊòØÂê¶Â∑≤Â≠òÂú®
    {
        let wallets_guard = state.wallets.lock().unwrap();
        if wallets_guard.contains_key(address) {
            return Err((StatusCode::CONFLICT, Json(ErrorResponse {
                error: "Ê≠§Èå¢ÂåÖÂú∞ÂùÄÂ∑≤Â≠òÂú®".to_string(),
            })));
        }
        
        // Ê™¢Êü•ÂêçÁ®±ÊòØÂê¶Â∑≤Â≠òÂú®
        for wallet in wallets_guard.values() {
            if wallet.name == name {
                return Err((StatusCode::CONFLICT, Json(ErrorResponse {
                    error: "Ê≠§Èå¢ÂåÖÂêçÁ®±Â∑≤Â≠òÂú®".to_string(),
                })));
            }
        }
    }
    
    // ÂâµÂª∫Êñ∞Èå¢ÂåÖ
    let new_wallet = WalletBalance::new(address.to_string(), name.to_string());
    
    // ÂòóË©¶ÂàùÂßãÂåñÈå¢ÂåÖÈ§òÈ°ç (‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑRPCÁ´ØÈªû)
    let rpc_endpoint = &state.config.rpc.endpoint;
    match query_wallet_balance(address, rpc_endpoint).await {
        Ok((sol_balance, wsol_balance)) => {
            let mut new_wallet = new_wallet;
            new_wallet.update_sol((sol_balance * 1_000_000_000.0) as u64);
            new_wallet.initialize_wsol(wsol_balance);
            
            // Ê∑ªÂä†Âà∞Èå¢ÂåÖÂàóË°®
            // ‰øùÂ≠òÂàùÂßãË®òÈåÑÂà∞Ë≥áÊñôÂ∫´
            let initial_record = WalletHistoryRecord::new(
                address.to_string(),
                new_wallet.sol_balance,
                new_wallet.wsol_balance,
            );
            if let Err(e) = save_wallet_history(&state.database, &initial_record) {
                warn!("‚ö†Ô∏è ‰øùÂ≠òÂàùÂßãÊ≠∑Âè≤Ë®òÈåÑÂ§±Êïó: {}", e);
            }

            {
                let mut wallets_guard = state.wallets.lock().unwrap();
                wallets_guard.insert(address.to_string(), new_wallet);
            }
            
            // Êõ¥Êñ∞ÈÖçÁΩÆÊñá‰ª∂
            if let Err(e) = update_config_file(address, name).await {
                warn!("‚ö†Ô∏è Êõ¥Êñ∞ÈÖçÁΩÆÊñá‰ª∂Â§±Êïó: {}", e);
            }
            
            // Ëß∏Áôº gRPC ÊµÅÈáçÂïü‰ª•Ë®ÇÈñ±Êñ∞Èå¢ÂåÖ
            {
                let mut restart_signal = state.grpc_restart_signal.lock().unwrap();
                *restart_signal = true;
            }
            
            info!("‚úÖ ÊàêÂäüÊñ∞Â¢ûÈå¢ÂåÖ: {} ({}) - Ê≠£Âú®ÈáçÂïügRPCË®ÇÈñ±", name, &address[..8]);
            
            Ok(Json(ApiResponse {
                success: true,
                message: format!("ÊàêÂäüÊñ∞Â¢ûÈå¢ÂåÖ {}", name),
            }))
        }
        Err(e) => {
            error!("‚ùå ÂàùÂßãÂåñÈå¢ÂåÖÈ§òÈ°çÂ§±Êïó: {}", e);
            Err((StatusCode::INTERNAL_SERVER_ERROR, Json(ErrorResponse {
                error: "ÁÑ°Ê≥ïÁç≤ÂèñÈå¢ÂåÖÈ§òÈ°çÔºåË´ãÊ™¢Êü•Âú∞ÂùÄÊòØÂê¶Ê≠£Á¢∫".to_string(),
            })))
        }
    }
}

async fn delete_wallet(
    Path(address): Path<String>,
    axum::extract::State(state): axum::extract::State<AppState>,
) -> Result<Json<ApiResponse>, (StatusCode, Json<ErrorResponse>)> {
    let wallet_name = {
        let mut wallets_guard = state.wallets.lock().unwrap();
        if let Some(wallet) = wallets_guard.remove(&address) {
            wallet.name.clone()
        } else {
            return Err((StatusCode::NOT_FOUND, Json(ErrorResponse {
                error: "Èå¢ÂåÖ‰∏çÂ≠òÂú®".to_string(),
            })));
        }
    };
    
    // Âà™Èô§Ë≥áÊñôÂ∫´‰∏≠ÁöÑÊ≠∑Âè≤Ë®òÈåÑ
    if let Err(e) = delete_wallet_history(&state.database, &address) {
        warn!("‚ö†Ô∏è Âà™Èô§Èå¢ÂåÖÊ≠∑Âè≤Ë®òÈåÑÂ§±Êïó: {}", e);
    }
    
    // Êõ¥Êñ∞ÈÖçÁΩÆÊñá‰ª∂
    if let Err(e) = remove_from_config_file(&address).await {
        warn!("‚ö†Ô∏è Êõ¥Êñ∞ÈÖçÁΩÆÊñá‰ª∂Â§±Êïó: {}", e);
    }
    
    // Ëß∏Áôº gRPC ÊµÅÈáçÂïü‰ª•ÂÅúÊ≠¢Ë®ÇÈñ±Â∑≤Âà™Èô§ÁöÑÈå¢ÂåÖ
    {
        let mut restart_signal = state.grpc_restart_signal.lock().unwrap();
        *restart_signal = true;
    }
    
    info!("‚úÖ ÊàêÂäüÂà™Èô§Èå¢ÂåÖ: {} ({}) - Ê≠£Âú®ÈáçÂïügRPCË®ÇÈñ±", wallet_name, &address[..8]);
    
    Ok(Json(ApiResponse {
        success: true,
        message: format!("ÊàêÂäüÂà™Èô§Èå¢ÂåÖ {}", wallet_name),
    }))
}

async fn websocket_handler(
    ws: WebSocketUpgrade,
    axum::extract::State(state): axum::extract::State<AppState>,
) -> Response {
    ws.on_upgrade(|socket| websocket_connection(socket, state.wallets))
}

async fn websocket_connection(mut socket: WebSocket, wallets: SharedWallets) {
    let mut interval = tokio::time::interval(Duration::from_secs(1));
    let mut last_sent_data: Option<HashMap<String, (f64, f64, f64, DateTime<Utc>)>> = None; // address -> (sol, wsol, total, timestamp)
    
    loop {
        tokio::select! {
            _ = interval.tick() => {
                let current_data: HashMap<String, (f64, f64, f64, DateTime<Utc>)> = {
                    let wallets_guard = wallets.lock().unwrap();
                    wallets_guard.iter().map(|(addr, wallet)| {
                        (addr.clone(), (wallet.sol_balance, wallet.wsol_balance, wallet.total_balance(), wallet.last_update))
                    }).collect()
                };
                
                // Ê™¢Êü•ËÆäÂåñ‰∏¶Êî∂ÈõÜÊõ¥Êñ∞ÁöÑÈå¢ÂåÖ
                let mut updates = Vec::new();
                
                for (address, (sol, wsol, total, timestamp)) in &current_data {
                    let has_change = match &last_sent_data {
                        None => true, // Á¨¨‰∏ÄÊ¨°ÁôºÈÄÅ
                        Some(last_data) => {
                            match last_data.get(address) {
                                None => true, // Êñ∞Èå¢ÂåÖ
                                Some((last_sol, last_wsol, last_total, last_timestamp)) => {
                                    // Ê™¢Êü•È§òÈ°çÊàñÊôÇÈñìÊà≥ÊòØÂê¶ÊúâËÆäÂåñ
                                    (sol - last_sol).abs() > f64::EPSILON ||
                                    (wsol - last_wsol).abs() > f64::EPSILON ||
                                    (total - last_total).abs() > f64::EPSILON ||
                                    timestamp != last_timestamp
                                }
                            }
                        }
                    };
                    
                    if has_change {
                        // Áç≤ÂèñÈå¢ÂåÖË©≥Á¥∞‰ø°ÊÅØ
                        let wallets_guard = wallets.lock().unwrap();
                        if let Some(wallet) = wallets_guard.get(address) {
                            // Âè™ÁôºÈÄÅÊúÄÊñ∞ÁöÑ‰∏ÄÁ≠ÜÊ≠∑Âè≤Êï∏Êìö
                            let latest_history = wallet.history.back().cloned();
                            
                            let update = serde_json::json!({
                                "type": "update",
                                "wallet": {
                                    "address": wallet.address,
                                    "name": wallet.name,
                                    "sol_balance": wallet.sol_balance,
                                    "wsol_balance": if wallet.wsol_initialized { wallet.wsol_balance } else { 0.0 },
                                    "total_balance": wallet.total_balance(),
                                    "last_update": wallet.last_update,
                                    "latest_data": latest_history.map(|h| serde_json::json!({
                                        "time": h.timestamp.timestamp(),
                                        "sol_balance": h.sol_balance,
                                        "wsol_balance": h.wsol_balance,
                                        "total_balance": h.total_balance
                                    }))
                                }
                            });
                            updates.push(update);
                        }
                    }
                }
                
                // Ê™¢Êü•ÊòØÂê¶ÊúâÈå¢ÂåÖË¢´Âà™Èô§
                if let Some(ref last_data) = last_sent_data {
                    for address in last_data.keys() {
                        if !current_data.contains_key(address) {
                            let delete_update = serde_json::json!({
                                "type": "delete",
                                "address": address
                            });
                            updates.push(delete_update);
                        }
                    }
                }
                
                // ÁôºÈÄÅÊõ¥Êñ∞
                if !updates.is_empty() {
                    let message = serde_json::json!({
                        "type": "batch_update",
                        "updates": updates
                    });
                    
                    if socket.send(axum::extract::ws::Message::Text(message.to_string())).await.is_err() {
                        break;
                    }
                    
                    info!("üì° WebSocket ÁôºÈÄÅ {} ÂÄãÈå¢ÂåÖÊõ¥Êñ∞ (Âè™Âê´ÊúÄÊñ∞Êï∏Êìö)", updates.len());
                    last_sent_data = Some(current_data);
                } else {
                    debug!("üì° WebSocket ÁÑ°ËÆäÂåñÔºåË∑≥ÈÅéÁôºÈÄÅ");
                }
            }
            msg = socket.recv() => {
                if msg.is_none() {
                    break;
                }
            }
        }
    }
}

async fn serve_index() -> Html<&'static str> {
    Html(include_str!("../web/index.html"))
}

// ËÆÄÂèñÈÖçÁΩÆÊ™îÊ°à
fn load_config() -> Result<Config, Box<dyn std::error::Error>> {
    let config_content = fs::read_to_string("config.toml")?;
    let mut config: Config = toml::from_str(&config_content)?;
    
    // Â¶ÇÊûúÊ≤íÊúâserverÈÖçÁΩÆÔºå‰ΩøÁî®ÈªòË™çÂÄº
    if config_content.find("[server]").is_none() {
        config.server = ServerConfig::default();
    }
    
    Ok(config)
}

// Ë®≠ÂÆöÊó•Ë™å
fn setup_logging(level: &str) {
    std::env::set_var("RUST_LOG", level);
    env_logger::init();
}

// Ë®àÁÆóÈå¢ÂåÖÁöÑ WSOL ATA Âú∞ÂùÄ
fn calculate_wsol_ata(wallet_address: &str) -> Result<String, Box<dyn std::error::Error>> {
    let wallet = ProgramPubkey::from_str(wallet_address)?;
    let wsol_mint = ProgramPubkey::from_str(WSOL_MINT)?;
    let associated_program_id = ProgramPubkey::from_str(ASSOCIATED_TOKEN_PROGRAM_ID)?;
    let token_program_id = ProgramPubkey::from_str(TOKEN_PROGRAM_ID)?;
    
    let (ata, _) = ProgramPubkey::find_program_address(
        &[wallet.as_ref(), token_program_id.as_ref(), wsol_mint.as_ref()],
        &associated_program_id,
    );
    
    Ok(ata.to_string())
}

// Ë®àÁÆóÊâÄÊúâÈå¢ÂåÖÁöÑ WSOL ATA Âú∞ÂùÄ
fn calculate_all_wsol_atas(wallet_addresses: &[String]) -> Vec<String> {
    let mut ata_addresses = Vec::new();
    
    for wallet_address in wallet_addresses {
        match calculate_wsol_ata(wallet_address) {
            Ok(ata) => {
                info!("üíé Èå¢ÂåÖ {} ÁöÑ WSOL ATA: {}", &wallet_address[..8], &ata[..8]);
                ata_addresses.push(ata);
            }
            Err(e) => {
                error!("‚ùå Ë®àÁÆóÈå¢ÂåÖ {} ÁöÑ WSOL ATA Â§±Êïó: {}", wallet_address, e);
            }
        }
    }
    
    ata_addresses
}

// ËôïÁêÜ WSOL Account Êõ¥Êñ∞
fn handle_wsol_account_update(
    update: SubscribeUpdate,
    wallets: &mut HashMap<String, WalletBalance>,
    ata_to_wallet_map: &HashMap<String, String>,
    db: &Database,
) -> Result<(), Box<dyn std::error::Error>> {
    if let Some(UpdateOneof::Account(account_update)) = update.update_oneof {
        if let Some(account) = account_update.account {
            let ata_address = bs58::encode(&account.pubkey).into_string();
            
            // Ê™¢Êü•ÊòØÂê¶ÊòØÊàëÂÄëÁõ£ËÅΩÁöÑ ATA Âú∞ÂùÄ
            if let Some(wallet_address) = ata_to_wallet_map.get(&ata_address) {
                // Ëß£Êûê token account Êï∏Êìö
                match TokenAccount::unpack(&account.data) {
                    Ok(token_account) => {
                        let wsol_balance = token_account.amount as f64 / 1_000_000_000.0; // WSOL decimals = 9
                        
                        if let Some(wallet) = wallets.get_mut(wallet_address) {
                            let old_balance = wallet.wsol_balance;
                            wallet.update_wsol(wsol_balance);
                            
                            if (wsol_balance - old_balance).abs() > 0.000001 {
                                info!("üíé Èå¢ÂåÖ {} WSOL È§òÈ°çËÆäÂåñ: {:.9} SOL (Âæû {:.9} Âà∞ {:.9})", 
                                      &wallet_address[..8], 
                                      wsol_balance - old_balance, 
                                      old_balance, 
                                      wsol_balance);
                                
                                wallet.print_balance("WSOLÂ∏≥Êà∂Êõ¥Êñ∞");
                                
                                // ‰øùÂ≠òÂà∞Ë≥áÊñôÂ∫´
                                let record = WalletHistoryRecord::new(
                                    wallet.address.clone(),
                                    wallet.sol_balance,
                                    wallet.wsol_balance,
                                );
                                if let Err(e) = save_wallet_history(db, &record) {
                                    warn!("‚ö†Ô∏è ‰øùÂ≠òWSOLÂ∏≥Êà∂Êõ¥Êñ∞Ë®òÈåÑÂ§±Êïó {}: {}", wallet.name, e);
                                }
                            }
                        }
                    }
                    Err(e) => {
                        warn!("‚ö†Ô∏è Ëß£Êûê token account Êï∏ÊìöÂ§±Êïó: {}", e);
                    }
                }
            }
        }
    }
    Ok(())
}

// Êü•Ë©¢Èå¢ÂåÖÈ§òÈ°ç (ÂàùÂßãÂåñÁî®)
async fn query_wallet_balance(wallet_address: &str, rpc_endpoint: &str) -> Result<(f64, f64), Box<dyn std::error::Error + Send + Sync>> {
    // ‰ΩøÁî® Solana RPC Client
    let client = RpcClient::new(rpc_endpoint.to_string());
    
    // Ëß£ÊûêÈå¢ÂåÖÂú∞ÂùÄ
    let owner_pubkey = Pubkey::from_str(wallet_address)?;
    
    // Êü•Ë©¢ SOL È§òÈ°ç
    let sol_lamports = client.get_balance(&owner_pubkey)?;
    let sol_balance = sol_lamports as f64 / 1_000_000_000.0;
    
    // Êü•Ë©¢ WSOL È§òÈ°ç - ‰ΩøÁî® ATA ÊñπÂºè
    let wsol_mint = Pubkey::from_str(WSOL_MINT)?;
    let ata = get_associated_token_address(&owner_pubkey, &wsol_mint);
    
    let wsol_balance = match client.get_token_account_balance(&ata) {
        Ok(balance) => balance.ui_amount.unwrap_or(0.0),
        Err(_) => 0.0, // ATA ‰∏çÂ≠òÂú®ÔºåÈ§òÈ°çÁÇ∫ 0
    };
    
    Ok((sol_balance, wsol_balance))
}

// ÂæûRPCÂàùÂßãÂåñÊâÄÊúâÈå¢ÂåÖÈ§òÈ°ç
async fn initialize_wallets_from_rpc(wallets: &mut HashMap<String, WalletBalance>, db: &Database, rpc_endpoint: &str) {
    let wallet_count = wallets.len();
    info!("üîÑ ÈñãÂßãÂæûRPCÁç≤Âèñ {} ÂÄãÈå¢ÂåÖÁöÑÊúÄÊñ∞È§òÈ°ç (‰ΩøÁî®ATAÊü•Ë©¢)", wallet_count);
    
    let mut processed_count = 0;
    
    for (address, wallet) in wallets.iter_mut() {
        processed_count += 1;
        info!("üìã Ê≠£Âú®Áç≤ÂèñÈå¢ÂåÖ {}/{} ÁöÑÊúÄÊñ∞È§òÈ°ç: {} ({})", processed_count, wallet_count, wallet.name, &address[..8]);
        
        // ÂæûRPCÁç≤ÂèñÊúÄÊñ∞ÁöÑSOLÂíåWSOLÈ§òÈ°ç
        match query_wallet_balance(address, rpc_endpoint).await {
            Ok((sol_balance, wsol_balance)) => {
                wallet.update_sol((sol_balance * 1_000_000_000.0) as u64);
                wallet.initialize_wsol(wsol_balance);
                info!("   üìä ÊúÄÊñ∞È§òÈ°ç - SOL: {:.6}, WSOL: {:.6}", sol_balance, wsol_balance);
            }
            Err(e) => {
                error!("‚ùå Áç≤ÂèñÈå¢ÂåÖ {} ÁöÑSOLÂíåWSOLÈ§òÈ°çÂ§±Êïó: {}", wallet.name, e);
                // Ë®≠ÁΩÆÁÇ∫0‰ª•ÈÅøÂÖçÊú™ÂàùÂßãÂåñÁãÄÊÖã
                wallet.initialize_wsol(0.0);
            }
        }
        
        wallet.print_balance("RPCÂàùÂßãÂåñ");
        
        // ‰øùÂ≠òÊúÄÊñ∞È§òÈ°çË®òÈåÑÂà∞Ë≥áÊñôÂ∫´
        if wallet.wsol_initialized {
            let current_record = WalletHistoryRecord::new(
                wallet.address.clone(),
                wallet.sol_balance,
                wallet.wsol_balance,
            );
            if let Err(e) = save_wallet_history(db, &current_record) {
                warn!("‚ö†Ô∏è ‰øùÂ≠òÊúÄÊñ∞È§òÈ°çË®òÈåÑÂ§±Êïó {}: {}", wallet.name, e);
            }
        }
    }
    
    info!("‚úÖ ÊâÄÊúâÈå¢ÂåÖÁöÑÊúÄÊñ∞È§òÈ°çÁç≤ÂèñÂÆåÊàêÔºÅ(ÁÑ°ÈúÄÁ≠âÂæÖÈñìÈöî)");
}



// ËôïÁêÜ SOL Account Êõ¥Êñ∞
fn handle_sol_account_update(
    update: SubscribeUpdate,
    wallets: &mut HashMap<String, WalletBalance>,
    wallet_addresses: &[String],
    db: &Database,
) -> Result<(), Box<dyn std::error::Error>> {
    if let Some(UpdateOneof::Account(account_update)) = update.update_oneof {
        if let Some(account) = account_update.account {
            let wallet_address = bs58::encode(&account.pubkey).into_string();
            
            // Ê™¢Êü•ÊòØÂê¶ÊòØÊàëÂÄëÁõ£ËÅΩÁöÑÈå¢ÂåÖÂú∞ÂùÄ
            if wallet_addresses.contains(&wallet_address) {
                if let Some(wallet) = wallets.get_mut(&wallet_address) {
                    let old_balance = wallet.sol_balance;
                    wallet.update_sol(account.lamports);
                    
                    if (wallet.sol_balance - old_balance).abs() > 0.000001 {
                        info!("üí∞ Èå¢ÂåÖ {} SOL È§òÈ°çËÆäÂåñ: {:.6} SOL (Âæû {:.6} Âà∞ {:.6})", 
                              &wallet_address[..8], 
                              wallet.sol_balance - old_balance, 
                              old_balance, 
                              wallet.sol_balance);
                        
                        wallet.print_balance("SOLÂ∏≥Êà∂Êõ¥Êñ∞");
                        
                        // ‰øùÂ≠òÂà∞Ë≥áÊñôÂ∫´
                        let record = WalletHistoryRecord::new(
                            wallet.address.clone(),
                            wallet.sol_balance,
                            wallet.wsol_balance,
                        );
                        if let Err(e) = save_wallet_history(db, &record) {
                            warn!("‚ö†Ô∏è ‰øùÂ≠òSOLÂ∏≥Êà∂Êõ¥Êñ∞Ë®òÈåÑÂ§±Êïó {}: {}", wallet.name, e);
                        }
                    }
                }
            }
        }
    }
    Ok(())
}

// ÈÖçÁΩÆÊñá‰ª∂Êìç‰ΩúÂáΩÊï∏
async fn update_config_file(address: &str, name: &str) -> Result<(), Box<dyn std::error::Error>> {
    let config_content = fs::read_to_string("config.toml")?;
    let mut lines: Vec<String> = config_content.lines().map(|s| s.to_string()).collect();
    
    // Ê∑ªÂä†Êñ∞ÁöÑÈå¢ÂåÖÈÖçÁΩÆ
    lines.push(String::new());
    lines.push("[[wallets]]".to_string());
    lines.push(format!("address = \"{}\"", address));
    lines.push(format!("name = \"{}\"", name));
    
    let updated_content = lines.join("\n");
    fs::write("config.toml", updated_content)?;
    
    Ok(())
}

async fn remove_from_config_file(address: &str) -> Result<(), Box<dyn std::error::Error>> {
    let config_content = fs::read_to_string("config.toml")?;
    let lines: Vec<&str> = config_content.lines().collect();
    let mut new_lines: Vec<&str> = Vec::new();
    let mut i = 0;
    
    while i < lines.len() {
        let line = lines[i];
        
        // Ê™¢Êü•ÊòØÂê¶ÊòØÈå¢ÂåÖÂçÄÂ°äÁöÑÈñãÂßã
        if line.trim() == "[[wallets]]" {
            // Êü•Áúã‰∏ã‰∏ÄË°åÊòØÂê¶ÂåÖÂê´Ë¶ÅÂà™Èô§ÁöÑÂú∞ÂùÄ
            let mut wallet_lines = vec![line];
            let mut j = i + 1;
            let mut found_target = false;
            
            // Êî∂ÈõÜÈÄôÂÄãÈå¢ÂåÖÂçÄÂ°äÁöÑÊâÄÊúâË°å
            while j < lines.len() {
                let next_line = lines[j];
                
                // Â¶ÇÊûúÈÅáÂà∞‰∏ã‰∏ÄÂÄãÂçÄÂ°äÊàñÊñá‰ª∂ÁµêÊùüÔºåÂÅúÊ≠¢Êî∂ÈõÜ
                if next_line.trim().starts_with("[") && next_line.trim() != "[[wallets]]" {
                    break;
                }
                
                // Â¶ÇÊûúÈÅáÂà∞‰∏ã‰∏ÄÂÄãÈå¢ÂåÖÂçÄÂ°äÔºåÂÅúÊ≠¢Êî∂ÈõÜ
                if next_line.trim() == "[[wallets]]" {
                    break;
                }
                
                wallet_lines.push(next_line);
                
                // Ê™¢Êü•ÊòØÂê¶ÂåÖÂê´ÁõÆÊ®ôÂú∞ÂùÄ
                if next_line.trim().starts_with("address = ") && next_line.contains(address) {
                    found_target = true;
                }
                
                j += 1;
                
                // Â¶ÇÊûúÈÅáÂà∞Á©∫Ë°å‰∏îÂ∑≤Á∂ìÊúâ‰∫Ü nameÔºåÈÄôÂÄãÈå¢ÂåÖÂçÄÂ°äÁµêÊùü
                if next_line.trim().is_empty() && wallet_lines.iter().any(|l| l.trim().starts_with("name = ")) {
                    break;
                }
            }
            
            // Â¶ÇÊûú‰∏çÊòØÁõÆÊ®ôÈå¢ÂåÖÔºå‰øùÁïôÈÄôÂÄãÂçÄÂ°ä
            if !found_target {
                for wallet_line in wallet_lines {
                    new_lines.push(wallet_line);
                }
            }
            
            // Ë∑≥ÈÅéÂ∑≤ËôïÁêÜÁöÑË°å
            i = j;
        } else {
            // ‰øùÁïôÈùûÈå¢ÂåÖÂçÄÂ°äÁöÑË°å
            new_lines.push(line);
            i += 1;
        }
    }
    
    let updated_content = new_lines.join("\n");
    fs::write("config.toml", updated_content)?;
    
    Ok(())
}

// ÂâµÂª∫gRPCÊµÅ
async fn create_grpc_stream(
    grpc_endpoint: String,
    wallets: SharedWallets,
    db: SharedDatabase,
    restart_signal: GrpcRestartSignal,
) -> Result<(), Box<dyn std::error::Error>> {
    loop {
        info!("üîÑ ÂòóË©¶ÈÄ£Êé•Âà∞ gRPC Á´ØÈªû: {}", grpc_endpoint);
        
        match GeyserGrpcClient::build_from_shared(grpc_endpoint.clone()) {
            Ok(client_builder) => {
                match client_builder.connect().await {
                    Ok(mut client) => {
                        info!("‚úÖ ÊàêÂäüÈÄ£Êé•Âà∞ gRPC ‰º∫ÊúçÂô®");
                        
                        let wallet_addresses: Vec<String> = {
                            let wallets_guard = wallets.lock().unwrap();
                            wallets_guard.keys().cloned().collect()
                        };
                        
                        info!("üìã Ê∫ñÂÇôË®ÇÈñ± {} ÂÄãÈå¢ÂåÖ:", wallet_addresses.len());
                        for (i, address) in wallet_addresses.iter().enumerate() {
                            let wallets_guard = wallets.lock().unwrap();
                            if let Some(wallet) = wallets_guard.get(address) {
                                info!("   {}: {} ({})", i + 1, wallet.name, &address[..8]);
                            } else {
                                info!("   {}: Êú™Áü•Èå¢ÂåÖ ({})", i + 1, &address[..8]);
                            }
                        }
                        
                        // Ë®àÁÆóÊâÄÊúâÈå¢ÂåÖÁöÑ WSOL ATA Âú∞ÂùÄ
                        let ata_addresses = calculate_all_wsol_atas(&wallet_addresses);
                        
                        // ÂâµÂª∫ ATA Âà∞Èå¢ÂåÖÂú∞ÂùÄÁöÑÊò†Â∞Ñ
                        let mut ata_to_wallet_map: HashMap<String, String> = HashMap::new();
                        for (wallet_addr, ata_addr) in wallet_addresses.iter().zip(ata_addresses.iter()) {
                            ata_to_wallet_map.insert(ata_addr.clone(), wallet_addr.clone());
                        }
                        
                        info!("üíé Ê∫ñÂÇôÁõ£ËÅΩ {} ÂÄã WSOL ATA Âú∞ÂùÄ", ata_addresses.len());
                        
                        let mut accounts_filter = HashMap::new();
                        accounts_filter.insert(
                            "wallet_accounts".to_string(),
                            SubscribeRequestFilterAccounts {
                                account: wallet_addresses.clone(),
                                owner: vec![],
                                filters: vec![],
                                nonempty_txn_signature: None,
                            },
                        );
                        
                        // Áõ£ËÅΩ WSOL ATA Âú∞ÂùÄ
                        accounts_filter.insert(
                            "wsol_ata_accounts".to_string(),
                            SubscribeRequestFilterAccounts {
                                account: ata_addresses.clone(),
                                owner: vec![],
                                filters: vec![],
                                nonempty_txn_signature: None,
                            },
                        );

                        let request = SubscribeRequest {
                            accounts: accounts_filter,
                            slots: HashMap::new(),
                            transactions: HashMap::new(), // ‰∏çÂÜçÁõ£ËÅΩ‰∫§Êòì
                            transactions_status: HashMap::new(),
                            blocks: HashMap::new(),
                            blocks_meta: HashMap::new(),
                            entry: HashMap::new(),
                            commitment: Some(CommitmentLevel::Confirmed as i32),
                            accounts_data_slice: vec![],
                            ping: None,
                            from_slot: None,
                        };

                        match client.subscribe().await {
                            Ok((mut subscribe_tx, mut subscribe_rx)) => {
                                if let Err(e) = subscribe_tx.send(request).await {
                                    error!("‚ùå ÁôºÈÄÅË®ÇÈñ±Ë´ãÊ±ÇÂ§±Êïó: {}", e);
                                    continue;
                                }
                                
                                info!("‚úÖ gRPC Ë®ÇÈñ±Ë´ãÊ±ÇÁôºÈÄÅÊàêÂäüÔºÅ");
                                info!("üéØ ÈñãÂßãÁõ£ËÅΩ {} ÂÄãÈå¢ÂåÖÁöÑËÆäÂåñ...", wallet_addresses.len());
                                
                                let mut first_message_received = false;
                                
                                while let Some(message) = subscribe_rx.next().await {
                                    // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÈáçÂïü
                                    {
                                        let mut signal = restart_signal.lock().unwrap();
                                        if *signal {
                                            *signal = false; // ÈáçÁΩÆ‰ø°Ëôü
                                            info!("üîÑ Êî∂Âà∞ÈáçÂïü‰ø°ËôüÔºåÊ≠£Âú®ÈáçÊñ∞Âª∫Á´ãgRPCË®ÇÈñ±...");
                                            break; // Ë∑≥Âá∫ÂÖßÂ±§Âæ™Áí∞ÔºåÈáçÊñ∞Âª∫Á´ãÈÄ£Êé•
                                        }
                                    }
                                    
                                    match message {
                                        Ok(update) => {
                                            if !first_message_received {
                                                info!("üéâ ÊàêÂäüÊé•Êî∂Âà∞Á¨¨‰∏ÄÂÄãgRPCÊ∂àÊÅØÔºåË®ÇÈñ±Ê≠£Â∏∏Â∑•‰ΩúÔºÅ");
                                                first_message_received = true;
                                            }
                                            {
                                                let mut wallets_guard = wallets.lock().unwrap();
                                                
                                                // Âè™ËôïÁêÜ Account Êõ¥Êñ∞ÔºàSOL Âíå WSOLÔºâ
                                                if let Some(UpdateOneof::Account(_)) = &update.update_oneof {
                                                    // ËôïÁêÜ SOL Â∏≥Êà∂Êõ¥Êñ∞
                                                    if let Err(e) = handle_sol_account_update(update.clone(), &mut wallets_guard, &wallet_addresses, &db) {
                                                        warn!("‚ö†Ô∏è ËôïÁêÜSOLÂ∏≥Êà∂Êõ¥Êñ∞ÊôÇÂá∫ÈåØ: {}", e);
                                                    }
                                                    // ËôïÁêÜ WSOL ATA Â∏≥Êà∂Êõ¥Êñ∞
                                                    if let Err(e) = handle_wsol_account_update(update, &mut wallets_guard, &ata_to_wallet_map, &db) {
                                                        warn!("‚ö†Ô∏è ËôïÁêÜWSOLÂ∏≥Êà∂Êõ¥Êñ∞ÊôÇÂá∫ÈåØ: {}", e);
                                                    }
                                                }
                                            }
                                        }
                                        Err(e) => {
                                            error!("‚ùå gRPC ÊµÅÈåØË™§: {}", e);
                                            break;
                                        }
                                    }
                                }
                            }
                            Err(e) => {
                                error!("‚ùå Âª∫Á´ãË®ÇÈñ±Â§±Êïó: {}", e);
                            }
                        }
                    }
                    Err(e) => {
                        error!("‚ùå ÈÄ£Êé•Â§±Êïó: {}", e);
                    }
                }
            }
            Err(e) => {
                error!("‚ùå Âª∫Á´ãÂÆ¢Êà∂Á´ØÂ§±Êïó: {}", e);
            }
        }
        
        warn!("‚è≥ 10ÁßíÂæåÈáçÊñ∞ÈÄ£Êé•...");
        tokio::time::sleep(tokio::time::Duration::from_secs(10)).await;
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // ËºâÂÖ•ÈÖçÁΩÆ
    let config = load_config()?;
    setup_logging(&config.logging.level);
    
    info!("üöÄ SOLÈå¢ÂåÖÁõ£ÊéßÂô®ÂïüÂãï");
    info!("üìä Áõ£Êéß {} ÂÄãÈå¢ÂåÖ", config.wallets.len());
    
    // ÂàùÂßãÂåñË≥áÊñôÂ∫´
    let database = match initialize_database() {
        Ok(db) => Arc::new(db),
        Err(e) => {
            error!("‚ùå Ë≥áÊñôÂ∫´ÂàùÂßãÂåñÂ§±Êïó: {}", e);
            return Err(e);
        }
    };

    // ËºâÂÖ•Ê≠∑Âè≤Ë≥áÊñô
    let history_data = match load_all_wallet_history(&database) {
        Ok(data) => {
            info!("üìñ ÊàêÂäüËºâÂÖ•Ê≠∑Âè≤Ë≥áÊñôÔºåÂåÖÂê´ {} ÂÄãÈå¢ÂåÖÁöÑË®òÈåÑ", data.len());
            data
        }
        Err(e) => {
            warn!("‚ö†Ô∏è ËºâÂÖ•Ê≠∑Âè≤Ë≥áÊñôÂ§±Êïó: {}ÔºåÂ∞áÂæûÁ©∫ÁôΩÈñãÂßã", e);
            HashMap::new()
        }
    };

    // ÂàùÂßãÂåñÈå¢ÂåÖËøΩËπ§Âô®
    let mut wallets_map = HashMap::new();
    for wallet_config in &config.wallets {
        let mut wallet = WalletBalance::new(wallet_config.address.clone(), wallet_config.name.clone());
        
        // ÂæûË≥áÊñôÂ∫´ËºâÂÖ•Ê≠∑Âè≤Êï∏ÊìöÔºà‰ΩÜ‰∏ç‰ΩøÁî®WSOLÈ§òÈ°çÔºåÂõ†ÁÇ∫ÂèØËÉΩÈÅéÊôÇÔºâ
        if let Some(records) = history_data.get(&wallet_config.address) {
            info!("üìö ÁÇ∫Èå¢ÂåÖ {} ËºâÂÖ• {} Ê¢ùÊ≠∑Âè≤Ë®òÈåÑ", wallet.name, records.len());
            wallet.load_history_from_db(records.clone());
        }
        
        wallets_map.insert(wallet_config.address.clone(), wallet);
    }
    
    // ÊâÄÊúâÈå¢ÂåÖÈÉΩÈúÄË¶ÅÂæûRPCÁç≤ÂèñÊúÄÊñ∞ÁöÑSOLÂíåWSOLÈ§òÈ°çÔºåÁ¢∫‰øùÊï∏ÊìöÊ∫ñÁ¢∫ÊÄß
    info!("üîÑ Ê≠£Âú®ÂæûRPCÁç≤ÂèñÊâÄÊúâÈå¢ÂåÖÁöÑÊúÄÊñ∞È§òÈ°ç...");
    initialize_wallets_from_rpc(&mut wallets_map, &database, &config.rpc.endpoint).await;
    
    let shared_wallets = Arc::new(Mutex::new(wallets_map));
    let grpc_restart_signal = Arc::new(Mutex::new(false));
    
    // ÂâµÂª∫ÊáâÁî®ÁãÄÊÖã
    let app_state = AppState {
        wallets: shared_wallets.clone(),
        database: database.clone(),
        grpc_restart_signal: grpc_restart_signal.clone(),
        config: config.clone(),
    };
    
    // ÂâµÂª∫WebÊáâÁî®
    let app = Router::new()
        .route("/", get(serve_index))
        .route("/api/wallets", get(get_wallets).post(add_wallet))
        .route("/api/wallets/:address", get(get_wallet_detail).delete(delete_wallet))
        .route("/api/chart", get(get_chart_data))
        .route("/ws", get(websocket_handler))
        .layer(CorsLayer::permissive())
        .with_state(app_state);
    
    // ÂïüÂãïËÉåÊôØ‰ªªÂãô
    let grpc_wallets = shared_wallets.clone();
    let grpc_database = database.clone();
    let grpc_signal = grpc_restart_signal.clone();
    let grpc_endpoint = config.grpc.endpoint.clone();
    tokio::spawn(async move {
        if let Err(e) = create_grpc_stream(grpc_endpoint, grpc_wallets, grpc_database, grpc_signal).await {
            error!("‚ùå gRPC ÊµÅ‰ªªÂãôÂ§±Êïó: {}", e);
        }
    });
    
    // ÁßªÈô§ÂÆöÊúüWSOLÊõ¥Êñ∞‰ªªÂãôÔºåÊîπÁÇ∫Âè™Âæû‰∫§Êòì‰∏≠Êõ¥Êñ∞WSOL
    
    // ÂïüÂãïWebÊúçÂãôÂô®
    let server_addr = format!("{}:{}", config.server.host, config.server.port);
    info!("üåê WebÊúçÂãôÂô®ÂïüÂãïÊñº http://{}", server_addr);
    
    let listener = tokio::net::TcpListener::bind(&server_addr).await?;
    axum::serve(listener, app).await?;
    
    Ok(())
}

